## 문제 풀이 👉 블로그에 업로드

https://velog.io/@dev_tmb/boj-%EB%B0%B1%EC%A4%80-1676-%ED%8C%A9%ED%86%A0%EB%A6%AC%EC%96%BC-%EA%B0%9C%EC%88%98

https://velog.io/@dev_tmb/%EB%B0%B1%EC%A4%80-11723-%EC%A7%91%ED%95%A9-JAVA

<br/><br/>
*강의 학습 내용 정리
# 제2-1장: 클래스, 객체, 참조변수
## 🔗 개념

### 1️⃣ 클래스(class)

C에서의 구조체와 같이 다양한 자료형을 하나로 묶어주는 역할
⇒ 클래스 자체를 하나의 **타입**으로 바라보자! (마치 int,double 처럼)

BUT 일반 변수 선언과는 달리 자바에서의 배열 선언과 같이 <strong>`new`</strong> 로 메모리를 할당하는 추가 작업이 필요하다.  = 객체

클래스는 참조변수와 객체를 찍어내기 위한 설계도 (= 타입을 지정하기 위한 수단)로 볼 수 있다.

### 2️⃣ 참조변수(reference variable)

int, doublce 등의 **프리미티브 타입은 변수 자체에 저장**이 되지만, 클래스 타입은 그 변수 안에 값이 저장되는 것이 아니라 객체를 따로 생성하여 그 안에 값을 저장해준다. 클래스 변수에는 객체에 대한 주소값(참조)이 저장되는데, 이에 의해서 ‘참조 변수’ 라고도 한다.

`Person a = new Person();`

위 코드에서 `a` 가 참조변수에 해당한다.

<aside>
📍 즉, <strong>프리미티브 타입이 아닌 모든 변수는 참조 변수</strong> 로, 실제 데이터가 저장될 객체를 new 명령으로 따로 만들어야 하고, 참조변수에는 이 객체를 가리킬 수 있는 주소를 저장한다.

</aside>

**C에서는 참조변수를 포인터라고 부른다. Java에서는 화살표 연산자와 점 연산자를 구분할 필요없이 모두 점 연산자로 멤버에 접근하는 방식으로 통일된다.*

### 3️⃣ 객체(object)

new 명령어에 의해서 생성한 클래스 타입의 참조 변수는 객체를 가리키고, 이는 오로지 new에 의해서만 생성이 가능하다. 이 객체에 접근 및 보관하는 것이 참조변수의 역할이다.

**반드시 객체로 생성이 되어 있어야 참조변수를 통한 접근이 가능하다.**

### 💻 CODE

*기억하면 좋은 코드!

```java
    // 버블 정렬 알고리즘
    private static void bubbleSort() {
        for (int i=n-1; i>0; i--) {
            for (int j=0; j<i; j++) {
                if (members[j].name.compareTo(members[j+1].name) > 0) {
                    Person1 tmp = members[j];
                    members[j] = members[j+1];
                    members[j+1] = tmp;
                }
            }
        }
    }
```

## 📓 메모하기

- 왜 main함수가 포함된 데이터 멤버들만 static으로 선언해야 할까?


<hr/>

# 제2-2장: 메서드와 생성자
## 🔗 개념

### 1️⃣ 메서드 (Member Function)

클래스는 서로 관련있는 데이터들을 하나의 단위로 묶어두기 위한 것이다. 이때 데이터들 뿐만 아니라, 그 데이터와 관련이 깊은 메서드를 함께 묶어둘 수 있다.

이를 통해 코드의 응집도(cohension)를 높이고 결합도(coupling)를 낮출 수 있다.

한 클래스 내에서 정의된 메서드 간에는 멤버 변수를 공유하여 매개변수 여러 개를 둘 필요없이 바로 접근하여 처리할 수 있다. 그럼에도 클래스는 실체가 없는 설계도에 불과하며, 이 클래스를 실행하는 것이 아니라 클래스 타입의 객체를 생성하여 메서드를 사용해야 한다.

> 즉, 멤버함수(메서드)는 객체를 생성해야만 참조변수를 통해 사용할 수 있다.
>

<aside>
📍 객체지향 프로그래밍에서 객체란 <strong>“데이터” + “메서드”</strong>이다.

- 데이터 = 객체의 정적 속성
- 메서드 = 객체의 기능(동적 속성)
</aside>

### 2️⃣ 생성자 (Constructor)

클래스 안에 그 클래스와 동일한 이름을 가지며, return 타입이 없는 특별한 메서드를 생성자라고 한다. 생성자는 객체 생성 시 자동으로 실행된다.

생성자가 반드시 매개변수를 받아야 하는 것은 아니며, 객체에 필요한 초기화 작업을 처리하는 개념으로 생각하면 된다.

### 💻 CODE

*기억하면 좋은 코드!

## 📓 메모하기

문제 - 입력으로 하나의 직교 다각형과 점 p가 주어질 때, 그 점이 다각형의 내부에 있는지 외부에 있는지 판단하는 프로그램

풀이 - 점 p를 기준으로 수평 또는 수직의 직선을 그렸을 때 **다각형의 변과 교차하는 횟수**에 따라 판단할 수 있다. ⇒ 짝수 : 외부 / 홀수 : 내부

# 제2-3장: static, public
## 🔗 개념

### static

<aside>
❗ static 멤버는 클래스 안에 실제로 존재하며, 객체에는 존재하지 않는다.

- static 멤버 = class 멤버
- non-static 멤버 = object 멤버
</aside>

**Questions.**

1️⃣ 왜 main 메서드는 반드시 static 이어야 하는가?

자바는 순수한 클래스들의 집합으로 이루어진다. 즉, 자바 프로그램에서 클래스 외부에 있을 수 있는 것은 없다.

하지만, 클래스로만 순수하게 존재한다면 아무것도 실행할 수가 없다. 누군가 main을 실행시킬 수 있는 객체를 생성하지 않는 한 main 메서드는 영원히 실행될 수 없으므로 무조건 main은 static으로 선언되어야 한다. main은 프로그램의 출발점이기 때문!

2️⃣ 왜 static 메서드에서 같은 클래스의 non-static 멤버를 액세스 할 수 없는가?

이전 실습 코드에서 main 메서드가 포함되어 있는 클래스에서는 나머지 멤버도 모두 static으로 선언했었고, main 메서드가 포함되어 있지 않는다면 이를 신경 쓰지 않아도 됐다. 그 이유는 static 멤버인 main 메서드에서 non-static 멤버를 액세스할 경우 오류가 발생하기 때문이다.

non-static 멤버를 오류 없이 액세스 하려면 new로 객체를 생성한 후 접근 연산자로 멤버에 접근하는 방식을 사용해야 한다.

3️⃣ 다른 클래스에 속한 static 멤버는 어떻게 액세스 하는가?

`클래스명.멤버`로 객체 생성 없이 바로 접근한다.

4️⃣ static 메서드/필드의 용도는?

- main 메서드
- 상수 or 클래스 당 하나만 유지하고 있으면 되는 값 또는 객체

  ex. Math.PI, System.out

- 순수하게 기능만으로 정의되는 메서드 → 대표적으로 수학 함수들이 있다.

  ex. Math.abs(k), Math.sqrt(n), Math.min(a,b)


> 실제 프로그램에서는 static 사용을 최소화하여 오직 main 메서드만 static으로 처리하는 것을 선호한다.
>

### public

<aside>
❗ <strong>접근 제어: public, private, default, protected</strong>

- public: 클래스 외부에서 접근 가능
- private: 클래스 내부에서만 접근 가능
- default: 동일 패키지에 있는 다른 클래스에서 접근 가능
- protected: 동일 패키지의 다른 클래스와 다른 패키지의 하위 클래스에서도 접근 가능
</aside>

private으로 선언하면 해당 멤버는 클래스 내부에서만 사용 가능하다.
→ 굳이 이 방식을 사용하는 이유는?   `데이터 캡슐화`

모든 데이터 멤버를 private 으로 만들고 필요한 경우에 public 한 get/set 메서드를 제공한다면 객체가 제공하는 메서드를 통하지 않고는 내부 데이터에 접근을 할 수 없어 보안적인 측면에서 유리해진다. = data encapsulation, information hiding

**getter/setter 개념*

## 📓 메모하기

- main 메서드만 static으로 처리하는 방법은 **자기 자신에 대한 객체를 main 에서 new로 생성**한 후, **수행하고자 하는 멤버에 접근**하는 방식이다.
- 실질적으로 main의 역할을 하는 멤버 함수를 따로 선언하는 것이 좋다.

  → static 과 non-static의 사용에 대한 혼란을 줄이는 데 유용하다.


> 인프런 권오흠 교수님의 ‘Java로 배우는 자료구조’ 강의의 학습 정리 내용입니다.
>
