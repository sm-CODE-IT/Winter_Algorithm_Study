<details>
<summary> 👩🏻‍💻 박예준 (Java) 알고리즘 스터디 커리큘럼 </summary>
<div>

#### 정렬

- Comparable, Comparator 을 이용한 Java 객체 정렬
- Comparable, Comparator 사용 예제
- Java 언어를 이용하여 정렬할 때 시간초과 문제
- List와 ArrayList의 차이
- 업캐스팅, 다운캐스팅이란
- Arrays.sort()와 Collections.sort()의 차이
- BufferedReader/BufferedWriter, InputStreamReader/OutputStreamWriter의 차이
- String, StringBuilder, StringBuffer의 차이
- counting sort(계수정렬)의 개념 및 시간복잡도
- Java Collections Framework
- java Map 인터페이스 구현체의 종류
- java Set 인터페이스 구현체의 종류
- java List 인터페이스 구현체의 종류
- java 자료형의 범위 (ex. Integer, Long, BigInteger, BigDecimal)
- 입력값 조건에 따른 java 자료형 선택 방법
- 문자열 분리를 위한 StringTokenizer와 String.spilt의 차이
- 문자열 분리를 위한 StringTokenizer와 String.spilt의 사용 예제
- BufferedReader/Scanner, Arrays.sort()/Collections.sort()에 따른 시간복잡도 분석

#### 수학1-1(나머지, 최대공약수, 최소공배수, GCD의 합, 진법)

- 최대공약수(GCD)를 구하는 방법 '유클리드 호제법'의 개념
- 최대공약수를 이용하여 최소공배수(LCM)를 구하는 방법
- 기본적인 아스키코드
- 10진수 <-> 2진수, 8진수, 16진수 변환 시 Integer API 사용

#### 수학1-2(소수, 소인수분해, 팩토리얼)

- 1~N 까지의 수에서 모든 소수를 구하는 방법 '에라토스테네스의 체'의 개념
- 소인수분해의 개념과 간단한 풀이법

#### 수학2-1(제곱, 행렬, 피보나치의 수, 이항계수, 파스칼의 삼각형)

- 분할정복을 이용하여 제곱을 구하는 방법
- 이진수의 원리를 이용하여 제곱을 구하는 방법
- 행렬의 곱 구하기
- 피사노 주기의 개념과 구하는 방법
- 음수 번째의 피보나치의 수에 대한 규칙성
- 이항계수 구하는 방법

#### 수학2-2(카탈란 수, 오일러 피 함수, 유클리드 알고리즘, 나머지 연산, 순열)

- 카탈란 수의 개념과 적용 사례
- 카탈란 수 구하는 방법
- 오일러 피 함수의 개념과 활용
- 오일러 피 함수 구하는 방법
- 사전순으로 다음에 오는 순열

#### 자료구조1(스택, 큐, 덱, 문자열)
- 스택(Stack)의 개념
- 스택(Stack) 관련 메서드
- 큐(Queue)의 개념
- 큐(Queue) 관련 메서드
- 덱(Deque, Double-ended Queue)의 개념
- 덱(Deque, Double-ended Queue) 관련 메서드
- String indexOf()의 사용법
- String substring()의 사용법

#### 자료구조2(스택, Disjoint-set, 비트마스크, 힙, 이진 탐색 트리)

- Disjoint-set(서로소 집합 자료구조)의 개념과 사용 예제
- Disjoint-set 구현 방법
- 비트마스크의 개념과 사용 이유
- 비트연산의 종류와 사용법
- 이진 트리의 개념과 종류
- 이진 트리와 관련된 용어들
- 최대힙의 삽입과 삭제
- 이진 탐색 트리의 개념

#### 트리와 이진 탐색

- 트리의 개념과 적용 사례
- 트리의 지름 개념과 구하는 방법
- 트리와 그래프의 차이점
- 이진 트리의 순회(전위, 중위, 후위 순회)
- 이진 탐색의 개념

#### 그래프1(그래프, DFS, BFS, 이분그래프, 사이클, 플러드 필)

- 그래프의 개념과 적용 사례
- 트리나 그래프를 방문 또는 탐색하는 방법 1: BFS(너비 우선 탐색)
- 트리나 그래프를 방문 또는 탐색하는 방법 2: DFS(깊이 우선 탐색)
- 이분 그래프의 개념
- 이분 그래프인지 확인하는 방법
- 사이클의 개념
- 플러드 필(Flood Fill) 알고리즘의 개념

#### 그래프2(DAG(Directed Acyclic Graph), 위상 정렬, 최소 비용 신장 트리(Minimum Spanning Tree), Prim, Kruskal, 최단 경로(Shortest Path), Bellman-Ford)

- DAG(Directed Acyclic Graph)의 개념
- 위상 정렬(Topological Sort)
- 최소 비용 신장 트리(MST, Minimum Spanning Tree)
- Prim MST 알고리즘
- Kruskal MST 알고리즘
- 최단 경로(Shortest Path)
- Bellman-Ford 알고리즘

#### 그래프2(다익스트라(Dijkstra), 플로이드(Floyd-Warshall), SPFA(Shortest Path Faster))
</div>
</details>

<br/><br/>

## 문제 풀이 👉 블로그에 업로드

https://velog.io/@dev_tmb/boj-%EB%B0%B1%EC%A4%80-1676-%ED%8C%A9%ED%86%A0%EB%A6%AC%EC%96%BC-%EA%B0%9C%EC%88%98

https://velog.io/@dev_tmb/%EB%B0%B1%EC%A4%80-11723-%EC%A7%91%ED%95%A9-JAVA

<br/><br/>
*강의 학습 내용 정리
# 제2-1장: 클래스, 객체, 참조변수
## 🔗 개념

### 1️⃣ 클래스(class)

C에서의 구조체와 같이 다양한 자료형을 하나로 묶어주는 역할
⇒ 클래스 자체를 하나의 **타입**으로 바라보자! (마치 int,double 처럼)

BUT 일반 변수 선언과는 달리 자바에서의 배열 선언과 같이 <strong>`new`</strong> 로 메모리를 할당하는 추가 작업이 필요하다.  = 객체

클래스는 참조변수와 객체를 찍어내기 위한 설계도 (= 타입을 지정하기 위한 수단)로 볼 수 있다.

### 2️⃣ 참조변수(reference variable)

int, doublce 등의 **프리미티브 타입은 변수 자체에 저장**이 되지만, 클래스 타입은 그 변수 안에 값이 저장되는 것이 아니라 객체를 따로 생성하여 그 안에 값을 저장해준다. 클래스 변수에는 객체에 대한 주소값(참조)이 저장되는데, 이에 의해서 ‘참조 변수’ 라고도 한다.

`Person a = new Person();`

위 코드에서 `a` 가 참조변수에 해당한다.

<aside>
📍 즉, <strong>프리미티브 타입이 아닌 모든 변수는 참조 변수</strong> 로, 실제 데이터가 저장될 객체를 new 명령으로 따로 만들어야 하고, 참조변수에는 이 객체를 가리킬 수 있는 주소를 저장한다.

</aside>

**C에서는 참조변수를 포인터라고 부른다. Java에서는 화살표 연산자와 점 연산자를 구분할 필요없이 모두 점 연산자로 멤버에 접근하는 방식으로 통일된다.*

### 3️⃣ 객체(object)

new 명령어에 의해서 생성한 클래스 타입의 참조 변수는 객체를 가리키고, 이는 오로지 new에 의해서만 생성이 가능하다. 이 객체에 접근 및 보관하는 것이 참조변수의 역할이다.

**반드시 객체로 생성이 되어 있어야 참조변수를 통한 접근이 가능하다.**

### 💻 CODE

*기억하면 좋은 코드!

```java
    // 버블 정렬 알고리즘
    private static void bubbleSort() {
        for (int i=n-1; i>0; i--) {
            for (int j=0; j<i; j++) {
                if (members[j].name.compareTo(members[j+1].name) > 0) {
                    Person1 tmp = members[j];
                    members[j] = members[j+1];
                    members[j+1] = tmp;
                }
            }
        }
    }
```

## 📓 메모하기

- 왜 main함수가 포함된 데이터 멤버들만 static으로 선언해야 할까?


<hr/>

# 제2-2장: 메서드와 생성자
## 🔗 개념

### 1️⃣ 메서드 (Member Function)

클래스는 서로 관련있는 데이터들을 하나의 단위로 묶어두기 위한 것이다. 이때 데이터들 뿐만 아니라, 그 데이터와 관련이 깊은 메서드를 함께 묶어둘 수 있다.

이를 통해 코드의 응집도(cohension)를 높이고 결합도(coupling)를 낮출 수 있다.

한 클래스 내에서 정의된 메서드 간에는 멤버 변수를 공유하여 매개변수 여러 개를 둘 필요없이 바로 접근하여 처리할 수 있다. 그럼에도 클래스는 실체가 없는 설계도에 불과하며, 이 클래스를 실행하는 것이 아니라 클래스 타입의 객체를 생성하여 메서드를 사용해야 한다.

> 즉, 멤버함수(메서드)는 객체를 생성해야만 참조변수를 통해 사용할 수 있다.
>

<aside>
📍 객체지향 프로그래밍에서 객체란 <strong>“데이터” + “메서드”</strong>이다.

- 데이터 = 객체의 정적 속성
- 메서드 = 객체의 기능(동적 속성)
</aside>

### 2️⃣ 생성자 (Constructor)

클래스 안에 그 클래스와 동일한 이름을 가지며, return 타입이 없는 특별한 메서드를 생성자라고 한다. 생성자는 객체 생성 시 자동으로 실행된다.

생성자가 반드시 매개변수를 받아야 하는 것은 아니며, 객체에 필요한 초기화 작업을 처리하는 개념으로 생각하면 된다.

### 💻 CODE

*기억하면 좋은 코드!

## 📓 메모하기

문제 - 입력으로 하나의 직교 다각형과 점 p가 주어질 때, 그 점이 다각형의 내부에 있는지 외부에 있는지 판단하는 프로그램

풀이 - 점 p를 기준으로 수평 또는 수직의 직선을 그렸을 때 **다각형의 변과 교차하는 횟수**에 따라 판단할 수 있다. ⇒ 짝수 : 외부 / 홀수 : 내부

# 제2-3장: static, public
## 🔗 개념

### static

<aside>
❗ static 멤버는 클래스 안에 실제로 존재하며, 객체에는 존재하지 않는다.

- static 멤버 = class 멤버
- non-static 멤버 = object 멤버
</aside>

**Questions.**

1️⃣ 왜 main 메서드는 반드시 static 이어야 하는가?

자바는 순수한 클래스들의 집합으로 이루어진다. 즉, 자바 프로그램에서 클래스 외부에 있을 수 있는 것은 없다.

하지만, 클래스로만 순수하게 존재한다면 아무것도 실행할 수가 없다. 누군가 main을 실행시킬 수 있는 객체를 생성하지 않는 한 main 메서드는 영원히 실행될 수 없으므로 무조건 main은 static으로 선언되어야 한다. main은 프로그램의 출발점이기 때문!

2️⃣ 왜 static 메서드에서 같은 클래스의 non-static 멤버를 액세스 할 수 없는가?

이전 실습 코드에서 main 메서드가 포함되어 있는 클래스에서는 나머지 멤버도 모두 static으로 선언했었고, main 메서드가 포함되어 있지 않는다면 이를 신경 쓰지 않아도 됐다. 그 이유는 static 멤버인 main 메서드에서 non-static 멤버를 액세스할 경우 오류가 발생하기 때문이다.

non-static 멤버를 오류 없이 액세스 하려면 new로 객체를 생성한 후 접근 연산자로 멤버에 접근하는 방식을 사용해야 한다.

3️⃣ 다른 클래스에 속한 static 멤버는 어떻게 액세스 하는가?

`클래스명.멤버`로 객체 생성 없이 바로 접근한다.

4️⃣ static 메서드/필드의 용도는?

- main 메서드
- 상수 or 클래스 당 하나만 유지하고 있으면 되는 값 또는 객체

  ex. Math.PI, System.out

- 순수하게 기능만으로 정의되는 메서드 → 대표적으로 수학 함수들이 있다.

  ex. Math.abs(k), Math.sqrt(n), Math.min(a,b)


> 실제 프로그램에서는 static 사용을 최소화하여 오직 main 메서드만 static으로 처리하는 것을 선호한다.
>

### public

<aside>
❗ <strong>접근 제어: public, private, default, protected</strong>

- public: 클래스 외부에서 접근 가능
- private: 클래스 내부에서만 접근 가능
- default: 동일 패키지에 있는 다른 클래스에서 접근 가능
- protected: 동일 패키지의 다른 클래스와 다른 패키지의 하위 클래스에서도 접근 가능
</aside>

private으로 선언하면 해당 멤버는 클래스 내부에서만 사용 가능하다.
→ 굳이 이 방식을 사용하는 이유는?   `데이터 캡슐화`

모든 데이터 멤버를 private 으로 만들고 필요한 경우에 public 한 get/set 메서드를 제공한다면 객체가 제공하는 메서드를 통하지 않고는 내부 데이터에 접근을 할 수 없어 보안적인 측면에서 유리해진다. = data encapsulation, information hiding

**getter/setter 개념*

## 📓 메모하기

- main 메서드만 static으로 처리하는 방법은 **자기 자신에 대한 객체를 main 에서 new로 생성**한 후, **수행하고자 하는 멤버에 접근**하는 방식이다.
- 실질적으로 main의 역할을 하는 멤버 함수를 따로 선언하는 것이 좋다.

  → static 과 non-static의 사용에 대한 혼란을 줄이는 데 유용하다.


> 인프런 권오흠 교수님의 ‘Java로 배우는 자료구조’ 강의의 학습 정리 내용입니다.
>
